<!DOCTYPE html>
<html>
<head>
    <title>P2P Video Chat Test</title>
    <style>
        body { 
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f0f2f5;
        }
        .video-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        .video-box {
            flex: 1;
            min-width: 300px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        .video-box video {
            width: 100%;
            height: 225px;
            object-fit: cover;
            background: #000;
        }
        .video-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            font-size: 14px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        button.danger {
            background: #dc3545;
        }
        .chat-container {
            margin: 20px 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
        }
        .chat-log {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #eee;
            margin: 10px 0;
            padding: 10px;
            background: #f9f9f9;
        }
        .chat-input {
            display: flex;
            gap: 10px;
        }
        .chat-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .chat-input button {
            padding: 8px 15px;
        }
        .message {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 4px;
            background: #e9ecef;
        }
        .message.self {
            background: #d1e7ff;
            text-align: right;
        }
        .log {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 13px;
            margin-top: 20px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background: #e9ecef;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>P2P Video Chat Test</h1>
    <p>Open this page in two browser windows to test the P2P connection.</p>
    
    <div class="controls">
        <button id="startButton">Start</button>
        <button id="callButton" disabled>Call</button>
        <button id="hangupButton" disabled>Hang Up</button>
        <button id="toggleVideo" disabled>Start Video</button>
        <button id="toggleAudio" disabled>Mute Audio</button>
    </div>
    
    <div id="status" class="status">Status: Not connected</div>
    
    <div class="video-container">
        <div class="video-box">
            <video id="localVideo" autoplay playsinline muted></video>
            <div class="video-label">Local Stream</div>
        </div>
        <div class="video-box">
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="video-label">Remote Stream</div>
        </div>
    </div>
    
    <div class="chat-container">
        <h3>Chat</h3>
        <div id="chatLog" class="chat-log"></div>
        <div class="chat-input">
            <input type="text" id="messageInput" placeholder="Type a message..." disabled>
            <button id="sendButton" disabled>Send</button>
        </div>
    </div>
    <div class="log" id="log"></div>

    <script>
        // DOM elements
        const startButton = document.getElementById('startButton');
        const callButton = document.getElementById('callButton');
        const hangupButton = document.getElementById('hangupButton');
        const toggleVideoButton = document.getElementById('toggleVideo');
        const toggleAudioButton = document.getElementById('toggleAudio');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');

        // DOM elements for chat
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const chatLog = document.getElementById('chatLog');

        // WebRTC variables
        let localStream;
        let remoteStream;
        let peerConnection;
        let dataChannel;
        let isVideoEnabled = false;
        let isAudioEnabled = true;
        let isCaller = false;
        let isCallInProgress = false;

        // Configuration
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // Logging function
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.style.color = type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : '#212529';
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type}] ${message}`);
        }

        // Update UI state
        function updateUI() {
            startButton.disabled = isCallInProgress;
            callButton.disabled = isCallInProgress || !localStream;
            hangupButton.disabled = !isCallInProgress;
            toggleVideoButton.disabled = !isCallInProgress || !localStream;
            toggleAudioButton.disabled = !isCallInProgress || !localStream;
            
            toggleVideoButton.textContent = isVideoEnabled ? 'Stop Video' : 'Start Video';
            toggleAudioButton.textContent = isAudioEnabled ? 'Mute Audio' : 'Unmute Audio';
            
            statusDiv.textContent = `Status: ${isCallInProgress ? 'In call' : 'Not connected'}`;
        }

        // Start local media
        async function start() {
            try {
                log('Requesting media devices...');
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true,
                    video: false // Start with audio only
                });
                
                // Set up local video
                localVideo.srcObject = localStream;
                
                // Set up remote stream
                remoteStream = new MediaStream();
                remoteVideo.srcObject = remoteStream;
                
                log('Local media ready');
                updateUI();
                startSignaling();
                
            } catch (err) {
                log(`Error accessing media devices: ${err.message}`, 'error');
            }
        }

        // Toggle video
        async function toggleVideo() {
            if (!localStream) return;
            
            if (!isVideoEnabled) {
                try {
                    // Get available video devices
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length === 0) {
                        log('No video devices found', 'error');
                        return;
                    }
                    
                    // Get video stream
                    const videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            deviceId: videoDevices[0].deviceId ? { exact: videoDevices[0].deviceId } : true 
                        } 
                    });
                    
                    const videoTrack = videoStream.getVideoTracks()[0];
                    if (videoTrack) {
                        // Add video track to local stream
                        localStream.addTrack(videoTrack);
                        isVideoEnabled = true;
                        log('Video enabled');
                        
                        // Update peer connection if in a call
                        if (peerConnection) {
                            const senders = peerConnection.getSenders();
                            const videoSender = senders.find(s => s.track && s.track.kind === 'video');
                            
                            if (videoSender) {
                                await videoSender.replaceTrack(videoTrack);
                            } else {
                                peerConnection.addTrack(videoTrack, localStream);
                            }
                            
                            // Re-negotiate the connection
                            if (isCaller) {
                                const offer = await peerConnection.createOffer();
                                await peerConnection.setLocalDescription(offer);
                                sendSignal({ type: 'offer', sdp: offer });
                            }
                        }
                        
                        updateUI();
                    }
                    
                } catch (err) {
                    log(`Error enabling video: ${err.message}`, 'error');
                }
            } else {
                // Disable video
                const videoTracks = localStream.getVideoTracks();
                if (videoTracks.length > 0) {
                    videoTracks.forEach(track => {
                        track.stop();
                        localStream.removeTrack(track);
                    });
                    
                    isVideoEnabled = false;
                    log('Video disabled');
                    
                    // Update peer connection if in a call
                    if (peerConnection) {
                        const senders = peerConnection.getSenders();
                        const videoSender = senders.find(s => s.track && s.track.kind === 'video');
                        
                        if (videoSender) {
                            peerConnection.removeTrack(videoSender);
                            
                            // Re-negotiate the connection
                            if (isCaller) {
                                const offer = await peerConnection.createOffer();
                                await peerConnection.setLocalDescription(offer);
                                sendSignal({ type: 'offer', sdp: offer });
                            }
                        }
                    }
                    
                    updateUI();
                }
            }
        }

        // Toggle audio
        function toggleAudio() {
            if (!localStream) return;
            
            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length > 0) {
                isAudioEnabled = !isAudioEnabled;
                audioTracks[0].enabled = isAudioEnabled;
                log(`Audio ${isAudioEnabled ? 'unmuted' : 'muted'}`);
                updateUI();
            }
        }

        // Start signaling
        function startSignaling() {
            if (isListening) return;
            
            // Listen for signals from other tabs
            window.addEventListener('storage', (event) => {
                if (event.key !== SIGNAL_KEY || !event.newValue) return;
                
                try {
                    const signal = JSON.parse(event.newValue);
                    handleSignal(signal);
                } catch (err) {
                    log(`Error parsing signal: ${err.message}`, 'error');
                }
            });
            
            isListening = true;
            log('Signaling ready');
        }

        // Send signal
        function sendSignal(signal) {
            localStorage.setItem(SIGNAL_KEY, JSON.stringify(signal));
            // Clear the signal after sending
            setTimeout(() => localStorage.removeItem(SIGNAL_KEY), 100);
        }

        // Set up data channel
        function setupDataChannel() {
            if (!peerConnection) return;
            
            if (isCaller) {
                // Create data channel if we're the caller
                dataChannel = peerConnection.createDataChannel('chat');
                setupDataChannelEvents();
            } else {
                // Set up data channel event handler if we're the callee
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannelEvents();
                };
            }
        }
        
        // Set up data channel events
        function setupDataChannelEvents() {
            if (!dataChannel) {
                log('No data channel available', 'error');
                return;
            }
            
            dataChannel.onopen = () => {
                log('Data channel opened', 'success');
                messageInput.disabled = false;
                sendButton.disabled = false;
                logChat('Connected to peer', false, true);
                
                // Send a test message to verify the channel is working
                try {
                    dataChannel.send('Test message from peer');
                } catch (err) {
                    log(`Error sending test message: ${err.message}`, 'error');
                }
            };
            
            dataChannel.onclose = () => {
                log('Data channel closed');
                messageInput.disabled = true;
                sendButton.disabled = true;
                logChat('Disconnected from peer', false, true);
            };
            
            dataChannel.onmessage = (event) => {
                log('Received message: ' + event.data);
                if (event.data === 'Test message from peer') {
                    logChat('Chat connection verified', false, true);
                } else {
                    logChat(event.data, false);
                }
            };
            
            dataChannel.onerror = (error) => {
                log(`Data channel error: ${error}`, 'error');
            };
        }
        
        // Send chat message
        function sendMessage() {
            const message = messageInput.value.trim();
            
            if (!message) return;
            
            if (!dataChannel) {
                log('No data channel available', 'error');
                return;
            }
            
            if (dataChannel.readyState !== 'open') {
                log(`Data channel state: ${dataChannel.readyState}`, 'error');
                return;
            }
            
            try {
                dataChannel.send(message);
                logChat(message, true);
                messageInput.value = '';
                messageInput.focus();
            } catch (err) {
                log(`Error sending message: ${err.message}`, 'error');
                logChat('Failed to send message', true, true);
            }
        }
        
        // Log chat message
        function logChat(message, isSelf = false, isSystem = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSelf ? 'self' : ''} ${isSystem ? 'system' : ''}`;
            messageDiv.textContent = message;
            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        // Create peer connection
        function createPeerConnection() {
            try {
                peerConnection = new RTCPeerConnection(config);
                
                // Add local tracks if they exist
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        log(`Adding local ${track.kind} track to peer connection`);
                        peerConnection.addTrack(track, localStream);
                    });
                } else {
                    log('No local stream available when creating peer connection', 'warning');
                }
                
                // Set up remote stream handling
                peerConnection.ontrack = (event) => {
                    log(`Received ${event.track.kind} track`);
                    
                    // Create a new stream for each track to handle multiple streams properly
                    if (!remoteVideo.srcObject) {
                        remoteVideo.srcObject = new MediaStream();
                    }
                    
                    const remoteMediaStream = remoteVideo.srcObject;
                    
                    // Remove any existing track of the same type
                    const existingTracks = remoteMediaStream.getTracks().filter(t => t.kind === event.track.kind);
                    existingTracks.forEach(track => {
                        track.stop();
                        remoteMediaStream.removeTrack(track);
                    });
                    
                    // Add the new track
                    remoteMediaStream.addTrack(event.track);
                    
                    // Make sure the video element is playing
                    if (event.track.kind === 'video') {
                        remoteVideo.style.display = 'block';
                        remoteVideo.play().catch(err => {
                            log(`Error playing remote video: ${err.message}`, 'error');
                        });
                    }
                    
                    // Log the track addition
                    log(`Added remote ${event.track.kind} track`);
                    
                    // Handle track ended event
                    event.track.onended = () => {
                        log(`Remote ${event.track.kind} track ended`);
                        if (remoteMediaStream) {
                            remoteMediaStream.removeTrack(event.track);
                        }
                    };
                };
                
                // Set up ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendSignal({ 
                            type: 'candidate', 
                            candidate: event.candidate 
                        });
                    }
                };
                
                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    log(`Connection state: ${peerConnection.connectionState}`);
                    
                    if (peerConnection.connectionState === 'disconnected' || 
                        peerConnection.connectionState === 'failed' || 
                        peerConnection.connectionState === 'closed') {
                        hangUp();
                    }
                };
                
                // Set up data channel
                setupDataChannel();
                log('Peer connection created');
                
            } catch (err) {
                log(`Error creating peer connection: ${err.message}`, 'error');
            }
        }

        // Handle incoming signals
        async function handleSignal(signal) {
            if (!signal) return;
            
            log(`Received signal: ${signal.type}`);
            
            switch (signal.type) {
                case 'offer':
                    if (isCallInProgress) return;
                    
                    try {
                        // Create peer connection if it doesn't exist
                        if (!peerConnection) {
                            createPeerConnection();
                        }
                        
                        // Set remote description
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                        
                        // Create and send answer
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        sendSignal({ type: 'answer', sdp: answer });
                        
                        isCallInProgress = true;
                        isCaller = false;
                        updateUI();
                        log('Call answered');
                        
                    } catch (err) {
                        log(`Error handling offer: ${err.message}`, 'error');
                    }
                    break;
                    
                case 'answer':
                    if (!peerConnection || !isCaller) return;
                    
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                        log('Call connected');
                        
                    } catch (err) {
                        log(`Error handling answer: ${err.message}`, 'error');
                    }
                    break;
                    
                case 'candidate':
                    if (!peerConnection) return;
                    
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                    } catch (err) {
                        if (signal.candidate) {
                            log(`Error adding ICE candidate: ${err.message}`, 'error');
                        }
                    }
                    break;
            }
        }

        // Start a call
        async function call() {
            if (isCallInProgress) return;
            
            try {
                createPeerConnection();
                
                // Create and send offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                sendSignal({ type: 'offer', sdp: offer });
                
                isCallInProgress = true;
                isCaller = true;
                updateUI();
                log('Call initiated');
                
            } catch (err) {
                log(`Error starting call: ${err.message}`, 'error');
            }
        }

        // Hang up
        function hangUp() {
            log('Hanging up call...');
            
            if (peerConnection) {
                // Close all transceivers
                peerConnection.getTransceivers().forEach(transceiver => {
                    if (transceiver.stop) {
                        transceiver.stop();
                    }
                });
                
                // Close the connection
                peerConnection.close();
                peerConnection = null;
                log('Peer connection closed');
            }
            
            // Clear data channel
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            // Clear chat
            chatLog.innerHTML = '';
            messageInput.value = '';
            messageInput.disabled = true;
            sendButton.disabled = true;
            
            // Clear remote stream
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => {
                    track.stop();
                    remoteStream.removeTrack(track);
                });
                remoteVideo.srcObject = null;
                remoteStream = new MediaStream();
                remoteVideo.srcObject = remoteStream;
            }
            
            isCallInProgress = false;
            isCaller = false;
            updateUI();
            
            log('Call ended');
        }

        // Event listeners
        startButton.addEventListener('click', start);
        callButton.addEventListener('click', call);
        hangupButton.addEventListener('click', hangUp);
        toggleVideoButton.addEventListener('click', toggleVideo);
        toggleAudioButton.addEventListener('click', toggleAudio);
        
        // Chat event listeners
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // Initialize
        updateUI();
        
        // Constants for signaling
        const SIGNAL_KEY = 'p2p-signal';
        let isListening = false;
        
        log('Test page loaded. Click "Start" to begin.');
    </script>
</body>
</html>
