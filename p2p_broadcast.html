<!DOCTYPE html>
<html>
<head>
    <title>P2P Video & Chat with BroadcastChannel</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 1000px; 
            margin: 0 auto; 
            padding: 20px; 
            line-height: 1.6;
        }
        .container { 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        .videos { 
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .video-container {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .debug-panel { flex: 1; }
        video { 
            width: 100%; 
            max-width: 400px; 
            background: #000; 
            margin: 10px 0;
            border-radius: 4px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            color: #212529;
        }
        .logs div { margin: 2px 0; }
        button { 
            padding: 8px 15px; 
            margin: 5px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            transition: background 0.2s;
        }
        button:hover { opacity: 0.9; }
        button:disabled { 
            background: #6c757d; 
            cursor: not-allowed; 
            opacity: 0.6;
        }
        #hangupButton { background: #dc3545; }
        #hangupButton:hover { background: #c82333; }
        .tab-buttons { margin: 10px 0; }
        .tab-buttons button { 
            background: #e9ecef; 
            color: #495057;
            border: 1px solid #dee2e6;
        }
        .tab-buttons button.active { 
            background: #007bff; 
            color: white;
            border-color: #007bff;
        }
        .chat-input { margin-top: 10px; display: flex; gap: 5px; }
        #messageInput { flex: 1; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>P2P with BroadcastChannel</h1>
    
    <div class="container">
        <div class="videos">
            <div class="video-container">
                <h3>Local Video</h3>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div class="video-container">
                <h3>Remote Video</h3>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
            
            <div class="controls">
                <button id="startButton" class="btn btn-primary">Start Camera</button>
                <button id="callButton" class="btn btn-success" disabled>Start Call</button>
                <button id="answerButton" class="btn btn-success" disabled>Answer Call</button>
                <button id="hangupButton" class="btn btn-danger" disabled>End Call</button>
                <button id="toggleVideoButton" class="btn btn-secondary" disabled>Toggle Video</button>
            </div>
            
            <div id="status">Status: Disconnected</div>
        </div>
        
        <div class="debug-panel">
            <h3>Chat</h3>
            <div id="chatLog" class="logs"></div>
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Type a message..." disabled>
                <button id="sendButton" disabled>Send</button>
            </div>
            
            <h3>Debug Logs</h3>
            <div id="log" class="logs"></div>
        </div>
    </div>

    <script>
        // Initialize BroadcastChannel for signaling
        const broadcastChannel = new BroadcastChannel('p2p_channel');

        // DOM Elements
        const startButton = document.getElementById('startButton');
        const callButton = document.getElementById('callButton');
        const hangupButton = document.getElementById('hangupButton');
        const toggleVideoButton = document.getElementById('toggleVideoButton');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const chatLog = document.getElementById('chatLog');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const tab1Button = document.getElementById('tab1');
        const tab2Button = document.getElementById('tab2');
        
        // State
        let localStream;
        let peerConnection;
        let dataChannel;
        
        // Simple peer identification
        const currentTab = 'caller';
        const peerTab = 'callee';
        
        // Log tab info
        console.log(`Current tab: ${currentTab}, Peer tab: ${peerTab}`);
        
        // UI State Management
        const UIState = {
            IDLE: 'idle',
            READY: 'ready',
            CALLING: 'calling',
            IN_CALL: 'in_call',
            ERROR: 'error'
        };

        let currentState = UIState.IDLE;
        let isCaller = false;

        // Logging
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            if (!logDiv) return;
            
            const entry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="color: #6c757d;">[${timestamp}]</span> ${message}`;
            
            if (type === 'error') entry.style.color = '#dc3545';
            else if (type === 'success') entry.style.color = '#28a745';
            else if (type === 'warn') entry.style.color = '#ffc107';
            
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function logChat(message, isSelf = false) {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = message;
            messageDiv.style.color = isSelf ? '#007bff' : '#28a745';
            messageDiv.style.textAlign = isSelf ? 'right' : 'left';
            messageDiv.style.margin = '5px 0';
            messageDiv.style.padding = '5px';
            messageDiv.style.backgroundColor = isSelf ? '#e9f5ff' : '#e8f8f0';
            messageDiv.style.borderRadius = '4px';
            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        // Handle incoming signals
        async function handleSignal(message) {
            try {
                if (!message) {
                    log('Received empty message', 'warn');
                    return;
                }

                log(`Processing signal type: ${message.type}`, 'debug');
                
                switch (message.type) {
                    case 'offer':
                        log('Processing offer...');
                        
                        // If we're the caller and receive an offer, we should be the callee
                        if (isCaller) {
                            log('Received offer while being the caller, switching to callee mode', 'info');
                            // Hang up existing call attempt
                            if (peerConnection) {
                                hangUp();
                            }
                                    isCaller = false;
                                }
                                
                                // Create a new peer connection if needed
                                if (!peerConnection) {
                                    createPeerConnection();
                                } else if (peerConnection.signalingState !== 'stable') {
                                    log('Peer connection not in stable state, creating new connection', 'warn');
                                    hangUp();
                                    createPeerConnection();
                                }
                                
                                try {
                                    // Set remote description with the offer
                                    await peerConnection.setRemoteDescription(new RTCSessionDescription({
                                        type: 'offer',
                                        sdp: message.sdp
                                    }));
                                    log('Set remote description with offer');
                                    
                                    // Create and send answer
                                    const answer = await peerConnection.createAnswer({
                                        offerToReceiveAudio: true,
                                        offerToReceiveVideo: true
                                    });
                                    
                                    await peerConnection.setLocalDescription(answer);
                                    log('Created answer');
                                    
                                    // Send the answer back to the caller
                                    sendSignal({ 
                                        type: 'answer', 
                                        sdp: answer.sdp,
                                        from: currentTab,
                                        to: peerTab
                                    });
                                    
                                    // Update UI
                                    callButton.disabled = true;
                                    hangupButton.disabled = false;
                                    messageInput.disabled = false;
                                    
                                    log('Call answered successfully');
                                    
                                } catch (err) {
                                    log(`Error handling offer: ${err.message}`, 'error');
                                    hangUp();
                                }
                                break;
                                
                            case 'answer':
                                log('Processing answer...');
                                if (isCaller && peerConnection) {
                                    try {
                                        await peerConnection.setRemoteDescription(new RTCSessionDescription({
                                            type: 'answer',
                                            sdp: message.sdp
                                        }));
                                        log('Set remote description with answer');
                                        
                                        // Update UI
                                        callButton.disabled = true;
                                        hangupButton.disabled = false;
                                        messageInput.disabled = false;
                                        
                                        log('Call connected successfully');
                                    } catch (err) {
                                        log(`Error setting remote description: ${err.message}`, 'error');
                                        hangUp();
                                    }
                                } else {
                                    log('Received answer but not in a call or not the caller', 'warn');
                                }
                                break;
                                
                            case 'candidate':
                                if (peerConnection && message.candidate) {
                                    log('Processing ICE candidate...');
                                    try {
                                        await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                                        log('Added ICE candidate');
                                    } catch (err) {
                                        if (err.name !== 'TypeError') {
                                            log(`Error adding ICE candidate: ${err.message}`, 'error');
                                        }
                                    }
                                }
                                break;
                                
                            default:
                                log(`Unknown message type: ${message.type}`, 'warn');
                        }
                    } catch (err) {
                        log(`Error processing message: ${err.message}`, 'error');
                        console.error('Error processing message:', err);
                    }
                };
        function setUIState(state) {
            currentState = state;
            
            // Reset all buttons first
            startButton.disabled = false;
            callButton.disabled = true;
            hangupButton.disabled = true;
            toggleVideoButton.disabled = true;
            messageInput.disabled = true;
            sendButton.disabled = true;

            switch (state) {
                case UIState.IDLE:
                    startButton.disabled = false;
                    break;
                    
                case UIState.READY:
                    callButton.disabled = false;
                    toggleVideoButton.disabled = false;
                    break;
                    
                case UIState.CALLING:
                    callButton.disabled = true;
                    hangupButton.disabled = false;
                    break;
                    
                case UIState.IN_CALL:
                    hangupButton.disabled = false;
                    toggleVideoButton.disabled = false;
                    messageInput.disabled = false;
                    sendButton.disabled = false;
                    break;
                    
                case UIState.ERROR:
                    // Keep all buttons disabled except start
                    startButton.disabled = false;
                    break;
            }
            
            log(`UI State: ${state}`);
        }

        // Start local media
        async function start() {
            try {
                setUIState(UIState.IDLE);
                log('Requesting media devices...');
                
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true,
                    video: true
                });
                
                localVideo.srcObject = localStream;
                log('Local media ready');
                
                // Set up peer connection
                createPeerConnection();
                
                // Update UI
                setUIState(UIState.READY);
                log('Ready to make or receive calls', 'success');
                
                // If this is the second tab, auto-start the call
                if (currentTab === 'tab2') {
                    setTimeout(() => call(), 1000);
                }
                
            } catch (err) {
                log(`Error accessing media devices: ${err.message}`, 'error');
                setUIState(UIState.ERROR);
                console.error('Start error:', err);
            }
        }

        // Toggle video
        async function toggleVideo() {
            if (!localStream) return;
            
            try {
                if (!localStream.getVideoTracks().length) {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    const videoTrack = stream.getVideoTracks()[0];
                    localStream.addTrack(videoTrack);
                    toggleVideoButton.textContent = 'Stop Video';
                    log('Video enabled');
                    
                    if (peerConnection) {
                        const senders = peerConnection.getSenders();
                        const videoSender = senders.find(s => s.track && s.track.kind === 'video');
                        
                        if (videoSender) {
                            await videoSender.replaceTrack(videoTrack);
                        } else {
                            peerConnection.addTrack(videoTrack, localStream);
                        }
                    }
                } else {
                    localStream.getVideoTracks().forEach(track => {
                        track.stop();
                        localStream.removeTrack(track);
                    });
                    toggleVideoButton.textContent = 'Start Video';
                    log('Video disabled');
                }
            } catch (err) {
                log(`Error toggling video: ${err.message}`, 'error');
            }
        }
        // Reconnect to peer
        async function reconnectPeer(peerConnection) {
            if (peerConnection.connectionState === 'connected') return;
            
            try {
                log('Attempting to reconnect peer...');
                const offer = await peerConnection.createOffer({
                    iceRestart: true
                });
                await peerConnection.setLocalDescription(offer);
                
                // Send the new offer
                sendSignal({
                    type: 'offer',
                    sdp: peerConnection.localDescription,
                    from: currentTab,
                    to: peerTab
                });
            } catch (error) {
                log(`Reconnection failed: ${error.message}`, 'error');
            }
        }

        // Create peer connection
        function createPeerConnection() {
            try {
                log('Creating peer connection with enhanced configuration');
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' },
                        // Add TURN server configuration (you'll need to replace with your own TURN server)
                        // {
                        //     urls: 'turn:your-turn-server.com:3478',
                        //     username: 'username',
                        //     credential: 'credential'
                        // }
                    ],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                    iceCandidatePoolSize: 10,
                    sdpSemantics: 'unified-plan'
                };
                
                const peerConnection = new RTCPeerConnection(configuration);
                
                // Add connection state change handler
                peerConnection.onconnectionstatechange = () => {
                    log(`Connection state changed to: ${peerConnection.connectionState}`);
                    
                    switch (peerConnection.connectionState) {
                        case 'connected':
                            log('Successfully connected to peer');
                            break;
                        case 'disconnected':
                        case 'failed':
                            log('Connection lost, attempting to reconnect...', 'warn');
                            setTimeout(() => reconnectPeer(peerConnection), 2000);
                            break;
                        case 'closed':
                            log('Connection closed');
                            break;
                    }
                };
                
                // Handle ICE candidate events
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        // Send the candidate to the remote peer
                        sendSignal({
                            type: 'candidate',
                            candidate: event.candidate,
                            from: currentTab,
                            to: peerTab
                        });
                    } else {
                        log('All ICE candidates have been sent', 'debug');
                    }
                };
                };
                
                peerConnection.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${peerConnection.iceConnectionState}`, 'debug');
                    
                    if (peerConnection.iceConnectionState === 'disconnected' ||
                        peerConnection.iceConnectionState === 'failed') {
                        log('Connection lost', 'error');
                        hangUp();
                    }
                };
                
                peerConnection.onsignalingstatechange = () => {
                    log(`Signaling state: ${peerConnection.signalingState}`, 'debug');
                };
                
                // Add local stream to peer connection if available
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });
                }
                
                // Set up data channel handler for incoming data channels
                peerConnection.ondatachannel = (event) => {
                    log('Data channel received', 'success');
                    dataChannel = event.channel;
                    setupDataChannel();
                };
                
                // If we're the caller, create the data channel
                if (isCaller) {
                    setupDataChannel();
                }
                
                peerConnection.ontrack = (event) => {
                    log('Received remote stream', 'success');
                    remoteVideo.srcObject = event.streams[0];
                };
                
                log('Peer connection created', 'success');
                return peerConnection;
                
            } catch (err) {
                log(`Error creating peer connection: ${err.message}`, 'error');
                throw err;
            }
        }

        // Set up data channel
        function setupDataChannel() {
            try {
                if (!peerConnection) {
                    log('No peer connection available', 'error');
                    return;
                }

                // Create data channel if it doesn't exist
                if (!dataChannel || dataChannel.readyState !== 'open') {
                    log('Creating new data channel...');
                    dataChannel = peerConnection.createDataChannel('chat', {
                        ordered: true,
                        maxRetransmits: 3
                    });
                }
                
                dataChannel.onopen = () => {
                    log('Data channel opened', 'success');
                    messageInput.disabled = false;
                    sendButton.disabled = false;
                    logChat('Chat connected', false);
                    
                    // Send a welcome message
                    try {
                        const welcomeMessage = `User ${currentTab} joined the chat at ${new Date().toLocaleTimeString()}`;
                        dataChannel.send(welcomeMessage);
                        log(`Sent welcome message`, 'debug');
                    } catch (err) {
                        log(`Error sending welcome message: ${err.message}`, 'error');
                    }
                };
                
                dataChannel.onclose = () => {
                    log('Data channel closed');
                    messageInput.disabled = true;
                    sendButton.disabled = true;
                    logChat('Chat disconnected', false);
                };
                
                dataChannel.onmessage = (event) => {
                    log(`Received message: ${event.data}`, 'info');
                    logChat(event.data, false);
                };
                
                dataChannel.onerror = (error) => {
                    log(`Data channel error: ${error.message || 'Unknown error'}`, 'error');
                };
                
                // Set binary type to arraybuffer for better compatibility
                dataChannel.binaryType = 'arraybuffer';
                
            } catch (err) {
                log(`Error setting up data channel: ${err.message}`, 'error');
            }
        }
        
        // Send a signal to the peer tab
        function sendSignal(signal) {
            if (!peerTab) {
                log('No peer tab set, cannot send signal', 'warn');
                return;
            }
            
            // Add from/to information
            signal.from = currentTab;
            signal.to = peerTab;
            
            // Create a clean copy and ensure it's a plain object
            const signalCopy = JSON.parse(JSON.stringify(signal));
            
            // Log the signal being sent
            console.log('Sending signal:', signalCopy);
            log(`Sending ${signal.type} to ${signal.to}`, 'debug');
            
            try {
                // Ensure we're sending a plain object
                broadcastChannel.postMessage(signalCopy);
                log(`Successfully sent ${signal.type} to ${signal.to}`, 'success');
            } catch (err) {
                console.error('Error sending signal:', err);
                log(`Error sending ${signal.type}: ${err.message}`, 'error');
                log(`Signal that caused error: ${JSON.stringify(signalCopy, null, 2)}`, 'debug');
            }
        }

        // Handle incoming signals
        async function handleSignal(event) {
            if (!event || !event.data) {
                log('Received empty signal', 'warn');
                return;
            }
            
            const signal = event.data;
            
            // Debug log all incoming signals
            log(`Received signal (type: ${signal.type || 'unknown'}, from: ${signal.from || 'unknown'}, to: ${signal.to || 'any'})`, 'debug');
            
            // If no 'to' field, assume it's for us
            if (signal.to && signal.to !== currentTab) {
                log(`Ignoring signal for ${signal.to} (current: ${currentTab})`, 'debug');
                return;
            }
            
            // Update peer tab if not set
            if (signal.from && signal.from !== currentTab) {
                log(`Updating peer tab to: ${signal.from}`);
                peerTab = signal.from;
            }
            
            // If we don't have a peer connection and it's not an offer, we can't handle it
            if (!peerConnection && signal.type !== 'offer') {
                log('No active peer connection for non-offer signal', 'warn');
                return;
            }
            
            log(`Processing ${signal.type} from ${signal.from || 'unknown'}`);
            
            try {
                switch (signal.type) {
                    case 'offer':
                        // If we're the caller and receive an offer, we should be the callee
                        if (isCaller) {
                            log('Received offer while being the caller, switching to callee mode', 'info');
                            // Hang up existing call attempt
                            if (peerConnection) {
                                hangUp();
                            }
                            isCaller = false;
                        }
                        
                        // Create a new peer connection if we don't have one
                        if (!peerConnection) {
                            createPeerConnection();
                        } else if (peerConnection.signalingState !== 'stable') {
                            log('Peer connection not in stable state, creating new connection', 'warn');
                            hangUp();
                            createPeerConnection();
                        }
                        
                        try {
                            // Set remote description with the offer
                            await peerConnection.setRemoteDescription(new RTCSessionDescription({
                                type: 'offer',
                                sdp: signal.sdp
                            }));
                            log('Set remote description');
                            
                            // Create and send answer
                            const answer = await peerConnection.createAnswer({
                                offerToReceiveAudio: true,
                                offerToReceiveVideo: true
                            });
                            
                            await peerConnection.setLocalDescription(answer);
                            log('Created answer');
                            
                            // Send the answer back to the caller
                            sendSignal({ 
                                type: 'answer', 
                                sdp: answer.sdp,
                                from: currentTab,
                                to: peerTab
                            });
                            
                            // Update UI
                            callButton.disabled = true;
                            hangupButton.disabled = false;
                            messageInput.disabled = false;
                            
                            log('Call answered successfully');
                            
                        } catch (err) {
                            log(`Error processing offer: ${err.message}`, 'error');
                            hangUp();
                        }
                        break;
                        
                    case 'answer':
                        if (isCaller && peerConnection) {
                            try {
                                await peerConnection.setRemoteDescription(new RTCSessionDescription({
                                    type: 'answer',
                                    sdp: signal.sdp
                                }));
                                log('Set remote description with answer');
                                
                                // Update UI
                                callButton.disabled = true;
                                hangupButton.disabled = false;
                                messageInput.disabled = false;
                                
                                log('Call connected successfully');
                            } catch (err) {
                                log(`Error setting remote description: ${err.message}`, 'error');
                                hangUp();
                            }
                        } else {
                            log('Received answer but not in a call or not the caller', 'warn');
                        }
                        break;
                        
                    case 'candidate':
                        if (peerConnection && signal.candidate) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                                log('Added ICE candidate');
                            } catch (err) {
                                if (err.name !== 'TypeError') {
                                    log(`Error adding ICE candidate: ${err.message}`, 'error');
                                }
                            }
                        }
                        break;
                        
                    default:
                        log(`Unknown signal type: ${signal.type}`, 'warn');
                }
            } catch (err) {
                log(`Error handling signal: ${err.message}`, 'error');
            }
        }

        // Start call
        async function call() {
            try {
                // If we already have a peer connection, check its state
                if (peerConnection) {
                    if (peerConnection.signalingState === 'have-local-offer') {
                        log('Already sent an offer, waiting for answer...', 'info');
                        return;
                    } else if (peerConnection.signalingState === 'have-remote-offer') {
                        log('Received an offer, auto-answering...', 'info');
                        // We're in the process of answering an offer, don't start a new call
                        return;
                    } else {
                        // In any other state, clean up and create a new connection
                        log('Resetting peer connection...', 'info');
                        hangUp();
                    }
                }
                
                isCaller = true;
                log('Initiating call...');
                
                createPeerConnection();
                
                // Create offer with better options
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true,
                    voiceActivityDetection: false,
                    iceRestart: false
                });
                
                // Set codec preferences for better compatibility
                const transceivers = peerConnection.getTransceivers();
                transceivers.forEach(transceiver => {
                    if (transceiver.sender.track && transceiver.sender.track.kind === 'video') {
                        const sendCodecs = RTCRtpSender.getCapabilities('video').codecs;
                        const preferredCodec = sendCodecs.find(codec => 
                            codec.mimeType === 'video/VP8' || 
                            codec.mimeType === 'video/H264'
                        );
                        if (preferredCodec) {
                            const codecs = [preferredCodec];
                            transceiver.setCodecPreferences(codecs);
                        }
                    }
                });
                
                await peerConnection.setLocalDescription(offer);
                log('Created offer');
                
                // Send the offer
                sendSignal({ 
                    type: 'offer', 
                    sdp: offer.sdp,
                    from: currentTab,
                    to: peerTab
                });
                
                // Update UI
                callButton.disabled = true;
                hangupButton.disabled = false;
                messageInput.disabled = false;
                
                log('Call initiated, waiting for answer...');
                
            } catch (err) {
                log(`Call error: ${err.message}`, 'error');
                // Reset UI on error
                callButton.disabled = false;
                hangupButton.disabled = true;
                messageInput.disabled = true;
                isCaller = false;
                
                // Clean up
                hangUp();
                
                // Show error to user
                alert(`Failed to start call: ${err.message}`);
            }
        }

        // Hang up
        function hangUp() {
            log('Ending call...');
            
            // Close peer connection
            if (peerConnection) {
                peerConnection.getTransceivers().forEach(transceiver => {
                    if (transceiver.stop) {
                        transceiver.stop();
                    }
                });
                peerConnection.close();
                peerConnection = null;
            }
            
            // Close data channel
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            // Reset remote video
            if (remoteVideo.srcObject) {
                remoteVideo.srcObject.getTracks().forEach(track => track.stop());
                remoteVideo.srcObject = null;
            }
            
            // Reset UI
            callButton.disabled = false;
            hangupButton.disabled = true;
            messageInput.disabled = true;
            sendButton.disabled = true;
            
            if (localStream) {
                const videoTracks = localStream.getVideoTracks();
                if (videoTracks.length > 0) {
                    toggleVideoButton.textContent = 'Stop Video';
                } else {
                    toggleVideoButton.textContent = 'Start Video';
                }
            }
            
            updateStatus(false);
            log('Call ended');
        }

        // Send chat message
        function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;
            
            if (!dataChannel) {
                log('No data channel available', 'error');
                return;
            }
            
            if (dataChannel.readyState !== 'open') {
                log('Data channel not ready. State: ' + dataChannel.readyState, 'error');
                return;
            }
            
            try {
                dataChannel.send(message);
                logChat(`You: ${message}`, true);
                messageInput.value = '';
                messageInput.focus();
                log('Message sent successfully', 'debug');
            } catch (err) {
                log(`Error sending message: ${err.message}`, 'error');
                log('Attempting to reconnect data channel...', 'warn');
                setupDataChannel(); // Try to re-establish the data channel
            }
        }

        // Role management
        function setRole(isCaller) {
            window.isCaller = isCaller;
            answerButton.style.display = isCaller ? 'none' : 'inline-block';
            callButton.style.display = isCaller ? 'inline-block' : 'none';
            log(`Role set to: ${isCaller ? 'Caller' : 'Callee'}`);
        }

        // Initialize UI
        function initUI() {
            // Initialize BroadcastChannel
            try {
                broadcastChannel = new BroadcastChannel('p2p_channel');
                log('BroadcastChannel initialized', 'success');
                
                // Log when the channel opens
                broadcastChannel.onopen = () => {
                    log('BroadcastChannel opened', 'debug');
                };
                
                // Log when the channel closes
                broadcastChannel.onclose = () => {
                    log('BroadcastChannel closed', 'debug');
                };
                
                // Log when the channel encounters an error
                broadcastChannel.onmessageerror = (error) => {
                    log(`BroadcastChannel error: ${error}`, 'error');
                };
                
            } catch (err) {
                log(`Failed to initialize BroadcastChannel: ${err.message}`, 'error');
            }
            
            // Set up event listeners
            startButton.addEventListener('click', start);
            callButton.addEventListener('click', call);
            hangupButton.addEventListener('click', hangUp);
            toggleVideoButton.addEventListener('click', toggleVideo);
            
            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
            
            tab1Button.addEventListener('click', () => switchTab('tab1'));
            tab2Button.addEventListener('click', () => switchTab('tab2'));
            
            // Set initial UI state
            callButton.disabled = true;
            hangupButton.disabled = true;
            toggleVideoButton.disabled = true;
            messageInput.disabled = true;
            sendButton.disabled = true;
            
            log('Page loaded. Click Start to begin.');
            updateStatus(false);
            switchTab('tab1');
        }
        
        // Set up signaling with enhanced logging
        broadcastChannel.onmessage = async (event) => {
            try {
                if (!event || !event.data) {
                    log('Received empty message', 'warn');
                    return;
                }
                
                const message = event.data;
                console.log('Raw message received:', message);
                log(`BroadcastChannel message received (type: ${message.type || 'unknown'}, from: ${message.from || 'unknown'}, to: ${message.to || 'any'})`);
                
                // Log current tab state
                log(`Current tab: ${currentTab}, Peer tab: ${peerTab}, IsCaller: ${isCaller}, PC state: ${peerConnection ? peerConnection.signalingState : 'no peer connection'}`);
                
                // Only process messages intended for this tab or broadcast messages
                if (message.to && message.to !== currentTab) {
                    log(`Ignoring message for ${message.to} (current tab: ${currentTab})`, 'debug');
                    return;
                }
                
                // Process the message
                await handleSignal(message);
            } catch (err) {
                console.error('Error in message handler:', err);
                log(`Error processing message: ${err.message}`, 'error');
            }
        };

        // Set up button event handlers
        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            // Set initial role based on URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const isCaller = urlParams.get('role') !== 'callee';
            setRole(isCaller);
            startButton.onclick = null;
            callButton.onclick = null;
            hangupButton.onclick = null;
            toggleVideoButton.onclick = null;
            sendButton.onclick = null;
            
            // Answer button (for callee)
            answerButton.onclick = (e) => {
                e.preventDefault();
                console.log('Answer button clicked');
                answerCall();
                return false;
            };
            
            // Main buttons
            startButton.onclick = (e) => {
                e.preventDefault();
                console.log('Start button clicked');
                start().catch(err => {
                    console.error('Start button error:', err);
                    log('Error starting: ' + err.message, 'error');
                    setUIState(UIState.ERROR);
                });
            };
            
            callButton.onclick = (e) => {
                e.preventDefault();
                console.log('Call button clicked');
                call().catch(err => {
                    console.error('Call button error:', err);
                    log('Error making call: ' + err.message, 'error');
                    setUIState(UIState.ERROR);
                });
            };
            
            hangupButton.onclick = (e) => {
                e.preventDefault();
                console.log('Hang up button clicked');
                hangUp();
            };
            
            toggleVideoButton.onclick = (e) => {
                e.preventDefault();
                console.log('Toggle video button clicked');
                toggleVideo().catch(err => {
                    console.error('Toggle video error:', err);
                    log('Error toggling video: ' + err.message, 'error');
                });
            };
            
            sendButton.onclick = (e) => {
                e.preventDefault();
                console.log('Send button clicked');
                sendMessage();
            };
            
            // Message input
            messageInput.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendMessage();
                }
            };
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded');
            
            // Set up event listeners first
            setupEventListeners();
            
            // Initialize tab state
            currentTab = sessionStorage.getItem('p2p_tab_id') || 'tab1';
            peerTab = currentTab === 'tab1' ? 'tab2' : 'tab1';
            
            console.log(`Initializing tab: ${currentTab}, peer: ${peerTab}`);
            
            // Set initial UI state
            setUIState(UIState.IDLE);
            
            // Log initial state
            log(`Page loaded in tab ${currentTab}`);
            log(`Looking for peer in ${peerTab}`);
            log('Click Start to begin');
            
            // Set initial UI state
            setUIState(UIState.IDLE);
            
            // Add debug helpers
            window.debug = {
                resetUI: () => setUIState(UIState.IDLE),
                getState: () => currentState,
                getStream: () => localStream,
                getPeerConnection: () => peerConnection,
                log: (msg) => log(msg, 'debug')
            };
            
            console.log('UI initialization complete');
        });
    </script>
</body>
</html>
